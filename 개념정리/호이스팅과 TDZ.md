# 호이스팅과 TDZ

## 호이스팅(Hoisting)
#### - 함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것<br> - 자바스크립트의 모든 선언에는 호이스팅이 일어난다. 그런데 var로 선언된 변수와 달리 let/const를 이용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다. 이는 스코프의 시작에서 변수의 선언까지 일시적 사각지대인 TDZ(Temporal Dead Zone)에 빠지기 때문이다.
<br>

### <호이스팅의 대상>
#### - var 변수 선언과 함수선언문에서만 호이스팅이 일어난다. <br>- var 변수/함수의 선언만 위로 끌어 올려지며, 할당은 끌어 올려지지 않는다.<br>- let/const 변수 선언과 함수표현식에서는 호이스팅이 발생하지 않는다.
```
foo();
  foo2();

  function foo() { // 함수선언문
          console.log("hello");
  }
  var foo2 = function() { // 함수표현식
          console.log("hello2");
  }
```
<br>
1. 함수선언문에서의 호이스팅

- 함수선언문은 코드를 구현한 위치와 관계없이 자바스크립트의 특징인 호이스팅에 따라 브라우저가 자바스크립트를 해석할 때 맨 위로 끌어올려진다. 

<br>
2. 함수표현식에서의 호이스팅

- 함수표현식은 함수선언문과 달리 선언과 호출 순서에 따라서 정상적으로 함수가 실행되지 않을 수 있다.<br>(함수표현식에서는 선언과 할당의 분리가 발생한다.)
  - 함수표현식 선언이 호출보다 위에 있는 경우 -> 정상 출력
  - 함수표현식 선언이 호출보다 아래있는 경우(var변수에 할당) -> TypeError
  - 함수표현식 선언이 호출보다 아래있는 경우(let/const변수에 할당) -> RederenceError

<br>

---

## 스코프(Scope)
#### - 범위, 영역을 일컫는데, 정확한 정의는 "식별자(변수, 함수, 클래스) 접근 규칙에 따른 유효 범위"이다. <br>- 범위는 중괄호(블록) 또는 함수에 의해 나눠진다.<br>- 자바스크립트에서는 전역스코프와 지역스코프 2가지 타입으로 스코프가 나뉜다.
- 전역 스코프는 말 그대로 전역에 선언되어있어 어느곳에서든지 해당 변수에 접근할 수 있ek.
- 지역 스코프는 해당 지역에서만 접근할 수 있어 지역을 벗어난 곳에선 접근할 수 없다.

```
// let x=5 //글로벌,전역스코프
// function myFuntion(){ //블록문(Block Statement):중괄호로 들러싸인 부분
//     let x=3; //로컬,지역스코프
//     console.log(x);
// }
// myFuntion();
// console.log(x)
```

<br>

---

## TDZ(Temporal Dead Zone/일시적 사각지대)
#### - 변수가 선언되고 변수의 초기화가 이루어지기 전까지의 구간 <br>- TDZ에서는 선언되기 전이거나 초기화 되기 전인 상태의 변수를 사용하는 것을 허용하지 않는다.   만약 TDZ구간 때 선언되지 않거나 초기화 전인 변수를 참조하게 되면 에러가 발생한다.
- var은 선언과 초기화 단계가 동시에 이루어진다
- let/const는 선언, 초기화, 할당 단계가 각각 따로 이루어진다. => TDZ의 영향을 받을 수 밖에 없다.

<br>

---

## 실행 컨텍스트(Execution context)/콜 스택(call stack)
<br>

### <실행 컨텍스트(Execution context)>
#### - 자바스크립트 코드가 실행되는 환경을 의미한다. <br>- 2가지 타입의 실행 컨텍스트가 있다. 
<br>
1. Global Execution context<br>

- 자바스크립트 엔진이 처음 코드를 실행할 때 Global Execution Context가 생성된다.
- 생성 과정에서 전역 객체인 Window Object (Node는 Global) 를 생성하고 this가 Window 객체를 가리키도록 한다.

<br>
2. Function Execution context

- 자바스크립트 엔진은 함수가 호출 될 때마다 호출 된 함수를 위한 Execution Context를 생성한다.
모든 함수는 호출되는 시점에 자신만의 Execution Context를 가진다.
- 자바스크립트는 실행 컨텍스트가 활성화되는 시점에 다음과 같은 현상이 발생한다.
  - 호이스팅이 발생한다(선언된 변수를 위로 끌어올린다)
  - 외부 환경 정보를 구성한다
  - this 값을 설정한다.

<br>

### <콜 스택(call stack)>
#### - 코드가 실행되면서 생성되는 실행 컨텍스트를 저장하는 자료구조
- 실행이 완료되면 콜스택에 쌓여있던 실행 컨텍스트는 제거되고, 이전 단계의 실행 컨텍스트가 호출된다.
- 일반적으로 전역 실행 컨텍스트가 가장 먼저 콜 스택에 쌓이게 되고, 그 뒤로 호출되는 함수들의 실행 컨텍스트 순서대로 쌓이게 된다. 다 쌓이게 되면 가장 늦게 쌓인 순서대로 실행되며, 마지막으로 전역 실행 컨텍스트가 실행된다.

<br>

---

## 스코프 체인(scope chain) / 변수 은닉화(variable shadowing)

### 실행 컨텍스트에서 스코프 체인(scope chain)은 어떻게 작동하는가?
- 실행 컨텍스트는 LIFO (Last in, First out) 구조의 스택으로, 코드 실행 중에 생성된 모든 실행 컨텍스트를 저장하는 데 사용된다.
- 실행 컨텍스트가 실행되면, 엔진이 스코프 체인을 통해 렉시컬 스코프를 먼저 파악한다.
- 그러고 나서, 함수가 중첩 상태일 때 하위 함수 내에서 상위 함수의 스코프와 전역 스코프까지 참조할 수 있는데 이것을 스코프 체인을 통해 탐색하는 것이다.

<br>

### <스코프 체인(Scope Chain)>
#### - 일종의 리스트로서 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고, 의미 그대로 각각의 스코프가 어떻게 연결(chain)되고 있는지 보여주는 것<br>- 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 '단방향'으로 연결한 링크드 리스트<br>

- 스코프는 함수의 중첩에 의해 계층적 구조를 가진다. <br> ⇒ 외부 함수(outer function) / 중첩 함수(nested function)
<br>
- 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프로 이동하면서 선언된 변수를 검색한다.<br>
- 스코프 체인은 outerEnvironmentReference와 밀접한 관계를 가진다.

- 여러 스코프에서 동일한 식별자를 선언한 경우, 무조건 스코프 체인 상에서 가장 먼저 검색된 식별자에만 접근 가능<br> ⇒ `변수 은닉화(variable shadowing)`

<br>

### <변수 은닉화(variable shadowing)>
#### - 직접적으로 변경되면 안 되는 변수에 대한 접근을 막는 것 